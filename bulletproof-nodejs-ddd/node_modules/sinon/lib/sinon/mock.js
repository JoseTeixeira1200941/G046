"use strict";

<<<<<<< HEAD
const arrayProto = require("@sinonjs/commons").prototypes.array;
const mockExpectation = require("./mock-expectation");
const proxyCallToString = require("./proxy-call").toString;
const extend = require("./util/core/extend");
const deepEqual = require("@sinonjs/samsam").deepEqual;
const wrapMethod = require("./util/core/wrap-method");
const usePromiseLibrary = require("./util/core/use-promise-library");

const concat = arrayProto.concat;
const filter = arrayProto.filter;
const forEach = arrayProto.forEach;
const every = arrayProto.every;
const join = arrayProto.join;
const push = arrayProto.push;
const slice = arrayProto.slice;
const unshift = arrayProto.unshift;
=======
var arrayProto = require("@sinonjs/commons").prototypes.array;
var mockExpectation = require("./mock-expectation");
var spyCallToString = require("./call").toString;
var extend = require("./util/core/extend");
var deepEqual = require("@sinonjs/samsam").deepEqual;
var wrapMethod = require("./util/core/wrap-method");
var usePromiseLibrary = require("./util/core/use-promise-library");

var concat = arrayProto.concat;
var filter = arrayProto.filter;
var forEach = arrayProto.forEach;
var every = arrayProto.every;
var join = arrayProto.join;
var push = arrayProto.push;
var slice = arrayProto.slice;
var unshift = arrayProto.unshift;
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99

function mock(object) {
    if (!object || typeof object === "string") {
        return mockExpectation.create(object ? object : "Anonymous mock");
    }

    return mock.create(object);
}

function each(collection, callback) {
<<<<<<< HEAD
    const col = collection || [];
=======
    var col = collection || [];
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99

    forEach(col, callback);
}

function arrayEquals(arr1, arr2, compareLength) {
    if (compareLength && arr1.length !== arr2.length) {
        return false;
    }

<<<<<<< HEAD
    return every(arr1, function (element, i) {
=======
    return every(arr1, function(element, i) {
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
        return deepEqual(arr2[i], element);
    });
}

extend(mock, {
    create: function create(object) {
        if (!object) {
            throw new TypeError("object is null");
        }

<<<<<<< HEAD
        const mockObject = extend.nonEnum({}, mock, { object: object });
=======
        var mockObject = extend.nonEnum({}, mock, { object: object });
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
        delete mockObject.create;

        return mockObject;
    },

    expects: function expects(method) {
        if (!method) {
            throw new TypeError("method is falsy");
        }

        if (!this.expectations) {
            this.expectations = {};
            this.proxies = [];
            this.failures = [];
        }

        if (!this.expectations[method]) {
            this.expectations[method] = [];
<<<<<<< HEAD
            const mockObject = this;

            wrapMethod(this.object, method, function () {
=======
            var mockObject = this;

            wrapMethod(this.object, method, function() {
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
                return mockObject.invokeMethod(method, this, arguments);
            });

            push(this.proxies, method);
        }

<<<<<<< HEAD
        const expectation = mockExpectation.create(method);
        expectation.wrappedMethod = this.object[method].wrappedMethod;
=======
        var expectation = mockExpectation.create(method);
        extend.nonEnum(expectation, this.object[method]);
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
        push(this.expectations[method], expectation);
        usePromiseLibrary(this.promiseLibrary, expectation);

        return expectation;
    },

    restore: function restore() {
<<<<<<< HEAD
        const object = this.object;

        each(this.proxies, function (proxy) {
=======
        var object = this.object;

        each(this.proxies, function(proxy) {
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
            if (typeof object[proxy].restore === "function") {
                object[proxy].restore();
            }
        });
    },

    verify: function verify() {
<<<<<<< HEAD
        const expectations = this.expectations || {};
        const messages = this.failures ? slice(this.failures) : [];
        const met = [];

        each(this.proxies, function (proxy) {
            each(expectations[proxy], function (expectation) {
=======
        var expectations = this.expectations || {};
        var messages = this.failures ? slice(this.failures) : [];
        var met = [];

        each(this.proxies, function(proxy) {
            each(expectations[proxy], function(expectation) {
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
                if (!expectation.met()) {
                    push(messages, String(expectation));
                } else {
                    push(met, String(expectation));
                }
            });
        });

        this.restore();

        if (messages.length > 0) {
            mockExpectation.fail(join(concat(messages, met), "\n"));
        } else if (met.length > 0) {
            mockExpectation.pass(join(concat(messages, met), "\n"));
        }

        return true;
    },

    usingPromise: function usingPromise(promiseLibrary) {
        this.promiseLibrary = promiseLibrary;

        return this;
    },

    invokeMethod: function invokeMethod(method, thisValue, args) {
        /* if we cannot find any matching files we will explicitly call mockExpection#fail with error messages */
        /* eslint consistent-return: "off" */
<<<<<<< HEAD
        const expectations =
            this.expectations && this.expectations[method]
                ? this.expectations[method]
                : [];
        const currentArgs = args || [];
        let available;

        const expectationsWithMatchingArgs = filter(
            expectations,
            function (expectation) {
                const expectedArgs = expectation.expectedArguments || [];

                return arrayEquals(
                    expectedArgs,
                    currentArgs,
                    expectation.expectsExactArgCount,
                );
            },
        );

        const expectationsToApply = filter(
            expectationsWithMatchingArgs,
            function (expectation) {
                return (
                    !expectation.met() &&
                    expectation.allowsCall(thisValue, args)
                );
            },
        );
=======
        var expectations = this.expectations && this.expectations[method] ? this.expectations[method] : [];
        var currentArgs = args || [];
        var available;

        var expectationsWithMatchingArgs = filter(expectations, function(expectation) {
            var expectedArgs = expectation.expectedArguments || [];

            return arrayEquals(expectedArgs, currentArgs, expectation.expectsExactArgCount);
        });

        var expectationsToApply = filter(expectationsWithMatchingArgs, function(expectation) {
            return !expectation.met() && expectation.allowsCall(thisValue, args);
        });
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99

        if (expectationsToApply.length > 0) {
            return expectationsToApply[0].apply(thisValue, args);
        }

<<<<<<< HEAD
        const messages = [];
        let exhausted = 0;

        forEach(expectationsWithMatchingArgs, function (expectation) {
=======
        var messages = [];
        var exhausted = 0;

        forEach(expectationsWithMatchingArgs, function(expectation) {
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
            if (expectation.allowsCall(thisValue, args)) {
                available = available || expectation;
            } else {
                exhausted += 1;
            }
        });

        if (available && exhausted === 0) {
            return available.apply(thisValue, args);
        }

<<<<<<< HEAD
        forEach(expectations, function (expectation) {
            push(messages, `    ${String(expectation)}`);
=======
        forEach(expectations, function(expectation) {
            push(messages, "    " + String(expectation));
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
        });

        unshift(
            messages,
<<<<<<< HEAD
            `Unexpected call: ${proxyCallToString.call({
                proxy: method,
                args: args,
            })}`,
        );

        const err = new Error();
=======
            "Unexpected call: " +
                spyCallToString.call({
                    proxy: method,
                    args: args
                })
        );

        var err = new Error();
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
        if (!err.stack) {
            // PhantomJS does not serialize the stack trace until the error has been thrown
            try {
                throw err;
            } catch (e) {
                /* empty */
            }
        }
        push(
            this.failures,
<<<<<<< HEAD
            `Unexpected call: ${proxyCallToString.call({
                proxy: method,
                args: args,
                stack: err.stack,
            })}`,
        );

        mockExpectation.fail(join(messages, "\n"));
    },
=======
            "Unexpected call: " +
                spyCallToString.call({
                    proxy: method,
                    args: args,
                    stack: err.stack
                })
        );

        mockExpectation.fail(join(messages, "\n"));
    }
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
});

module.exports = mock;
