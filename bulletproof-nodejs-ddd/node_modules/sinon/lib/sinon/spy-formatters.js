"use strict";

<<<<<<< HEAD
const arrayProto = require("@sinonjs/commons").prototypes.array;
const Colorizer = require("./color");
const color = new Colorizer();
const match = require("@sinonjs/samsam").createMatcher;
const timesInWords = require("./util/core/times-in-words");
const inspect = require("util").inspect;
const jsDiff = require("diff");

const join = arrayProto.join;
const map = arrayProto.map;
const push = arrayProto.push;
const slice = arrayProto.slice;

/**
 *
 * @param matcher
 * @param calledArg
 * @param calledArgMessage
 *
 * @returns {string} the colored text
 */
function colorSinonMatchText(matcher, calledArg, calledArgMessage) {
    let calledArgumentMessage = calledArgMessage;
    let matcherMessage = matcher.message;
    if (!matcher.test(calledArg)) {
        matcherMessage = color.red(matcher.message);
=======
var arrayProto = require("@sinonjs/commons").prototypes.array;
var color = require("./color");
var match = require("@sinonjs/samsam").createMatcher;
var timesInWords = require("./util/core/times-in-words");
var sinonFormat = require("./util/core/format");
var jsDiff = require("diff");

var join = arrayProto.join;
var map = arrayProto.map;
var push = arrayProto.push;

function colorSinonMatchText(matcher, calledArg, calledArgMessage) {
    var calledArgumentMessage = calledArgMessage;
    if (!matcher.test(calledArg)) {
        matcher.message = color.red(matcher.message);
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
        if (calledArgumentMessage) {
            calledArgumentMessage = color.green(calledArgumentMessage);
        }
    }
<<<<<<< HEAD
    return `${calledArgumentMessage} ${matcherMessage}`;
}

/**
 * @param diff
 *
 * @returns {string} the colored diff
 */
function colorDiffText(diff) {
    const objects = map(diff, function (part) {
        let text = part.value;
=======
    return calledArgumentMessage + " " + matcher.message;
}

function colorDiffText(diff) {
    var objects = map(diff, function(part) {
        var text = part.value;
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
        if (part.added) {
            text = color.green(text);
        } else if (part.removed) {
            text = color.red(text);
        }
        if (diff.length === 2) {
            text += " "; // format simple diffs
        }
        return text;
    });
    return join(objects, "");
}

<<<<<<< HEAD
/**
 *
 * @param value
 * @returns {string} a quoted string
 */
function quoteStringValue(value) {
    if (typeof value === "string") {
        return JSON.stringify(value);
    }
    return value;
}

module.exports = {
    c: function (spyInstance) {
        return timesInWords(spyInstance.callCount);
    },

    n: function (spyInstance) {
        // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
        return spyInstance.toString();
    },

    D: function (spyInstance, args) {
        let message = "";

        for (let i = 0, l = spyInstance.callCount; i < l; ++i) {
            // describe multiple calls
            if (l > 1) {
                message += `\nCall ${i + 1}:`;
            }
            const calledArgs = spyInstance.getCall(i).args;
            const expectedArgs = slice(args);

            for (
                let j = 0;
                j < calledArgs.length || j < expectedArgs.length;
                ++j
            ) {
                let calledArg = calledArgs[j];
                let expectedArg = expectedArgs[j];
                if (calledArg) {
                    calledArg = quoteStringValue(calledArg);
                }

                if (expectedArg) {
                    expectedArg = quoteStringValue(expectedArg);
                }

                message += "\n";

                const calledArgMessage =
                    j < calledArgs.length ? inspect(calledArg) : "";
                if (match.isMatcher(expectedArg)) {
                    message += colorSinonMatchText(
                        expectedArg,
                        calledArg,
                        calledArgMessage,
                    );
                } else {
                    const expectedArgMessage =
                        j < expectedArgs.length ? inspect(expectedArg) : "";
                    const diff = jsDiff.diffJson(
                        calledArgMessage,
                        expectedArgMessage,
                    );
=======
module.exports = {
    c: function(spyInstance) {
        return timesInWords(spyInstance.callCount);
    },

    n: function(spyInstance) {
        // eslint-disable-next-line local-rules/no-prototype-methods
        return spyInstance.toString();
    },

    D: function(spyInstance, args) {
        var message = "";

        for (var i = 0, l = spyInstance.callCount; i < l; ++i) {
            // describe multiple calls
            if (l > 1) {
                message += "\nCall " + (i + 1) + ":";
            }
            var calledArgs = spyInstance.getCall(i).args;
            for (var j = 0; j < calledArgs.length || j < args.length; ++j) {
                message += "\n";
                var calledArgMessage = j < calledArgs.length ? sinonFormat(calledArgs[j]) : "";
                if (match.isMatcher(args[j])) {
                    message += colorSinonMatchText(args[j], calledArgs[j], calledArgMessage);
                } else {
                    var expectedArgMessage = j < args.length ? sinonFormat(args[j]) : "";
                    var diff = jsDiff.diffJson(calledArgMessage, expectedArgMessage);
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
                    message += colorDiffText(diff);
                }
            }
        }

        return message;
    },

<<<<<<< HEAD
    C: function (spyInstance) {
        const calls = [];

        for (let i = 0, l = spyInstance.callCount; i < l; ++i) {
            // eslint-disable-next-line @sinonjs/no-prototype-methods/no-prototype-methods
            let stringifiedCall = `    ${spyInstance.getCall(i).toString()}`;
            if (/\n/.test(calls[i - 1])) {
                stringifiedCall = `\n${stringifiedCall}`;
=======
    C: function(spyInstance) {
        var calls = [];

        for (var i = 0, l = spyInstance.callCount; i < l; ++i) {
            // eslint-disable-next-line local-rules/no-prototype-methods
            var stringifiedCall = "    " + spyInstance.getCall(i).toString();
            if (/\n/.test(calls[i - 1])) {
                stringifiedCall = "\n" + stringifiedCall;
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
            }
            push(calls, stringifiedCall);
        }

<<<<<<< HEAD
        return calls.length > 0 ? `\n${join(calls, "\n")}` : "";
    },

    t: function (spyInstance) {
        const objects = [];

        for (let i = 0, l = spyInstance.callCount; i < l; ++i) {
            push(objects, inspect(spyInstance.thisValues[i]));
=======
        return calls.length > 0 ? "\n" + join(calls, "\n") : "";
    },

    t: function(spyInstance) {
        var objects = [];

        for (var i = 0, l = spyInstance.callCount; i < l; ++i) {
            push(objects, sinonFormat(spyInstance.thisValues[i]));
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
        }

        return join(objects, ", ");
    },

<<<<<<< HEAD
    "*": function (spyInstance, args) {
        return join(
            map(args, function (arg) {
                return inspect(arg);
            }),
            ", ",
        );
    },
=======
    "*": function(spyInstance, args) {
        return join(
            map(args, function(arg) {
                return sinonFormat(arg);
            }),
            ", "
        );
    }
>>>>>>> 8fea50a98e3683e334cf159da2406c53e1f99e99
};
